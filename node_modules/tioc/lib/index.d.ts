type Simplify<T extends object> = {
    [TKey in keyof T]: T[TKey];
} & {};
type SimplifyFn<T> = T extends (...args: infer A) => infer R ? (...args: A) => R : T;
type ServiceFactory<T = any, TContainer extends ServiceProvider = ServiceProvider> = (container: Simplify<TContainer>) => T;
type DescriptorType = "singleton" | "scoped" | "transient";
declare class ServiceRegistry<T extends Record<string, any> = {}> {
    private descriptors;
    private constructor();
    static create(): ServiceRegistry;
    private singletons;
    add<TKey extends string, TOutput>(type: DescriptorType, key: Exclude<TKey, keyof T>, factory: SimplifyFn<ServiceFactory<TOutput, ServiceProvider<T>>>): ServiceRegistry<Simplify<T & {
        [key in TKey]: TOutput;
    }>>;
    addSingleton<TKey extends string, TOutput>(key: Exclude<TKey, keyof T>, factory: SimplifyFn<ServiceFactory<TOutput, ServiceProvider<T>>>): ServiceRegistry<Simplify<T & {
        [key in TKey]: TOutput;
    }>>;
    addScoped<TKey extends string, TOutput>(key: Exclude<TKey, keyof T>, factory: SimplifyFn<ServiceFactory<TOutput, ServiceProvider<T>>>): ServiceRegistry<Simplify<T & {
        [key in TKey]: TOutput;
    }>>;
    addTransient<TKey extends string, TOutput>(key: Exclude<TKey, keyof T>, factory: SimplifyFn<ServiceFactory<TOutput, ServiceProvider<T>>>): ServiceRegistry<Simplify<T & {
        [key in TKey]: TOutput;
    }>>;
    scope(): Simplify<ServiceProvider<T>>;
}
type ServiceProvider<T extends Record<string, any> = Record<string, any>> = {
    [TKey in keyof T]: () => T[TKey];
};

export { type DescriptorType, type ServiceFactory, type ServiceProvider, ServiceRegistry };
