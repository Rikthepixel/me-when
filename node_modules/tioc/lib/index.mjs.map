{"version":3,"sources":["../src/index.ts"],"sourcesContent":["// Helpers\r\n\r\n// Unpacks object types to make them appear simpler in the IDE\r\ntype Simplify<T extends object> = {\r\n  [TKey in keyof T]: T[TKey];\r\n} & {};\r\n\r\n// Unpacks functions to make them appear simpler in the IDE\r\ntype SimplifyFn<T> = T extends (...args: infer A) => infer R\r\n  ? (...args: A) => R\r\n  : T;\r\n\r\n/**\r\n * Factory that produces an object using the {@link ServiceProvider}\r\n */\r\nexport type ServiceFactory<\r\n  T = any,\r\n  TContainer extends ServiceProvider = ServiceProvider,\r\n> = (container: Simplify<TContainer>) => T;\r\n\r\n/**\r\n * Available dependency scopes\r\n * - \"singleton\" Only instantiated once per {@link ServiceRegistry}\r\n * - \"scoped\" Only instantiated once per {@link ServiceProvider} (see {@link ServiceRegistry#scope})\r\n * - \"transient\" Instantiated every time it is requested\r\n */\r\nexport type DescriptorType = \"singleton\" | \"scoped\" | \"transient\";\r\n\r\ntype Descriptor<T, TContainer extends ServiceProvider> = {\r\n  type: DescriptorType;\r\n  factory: (container: TContainer) => T;\r\n};\r\n\r\n/**\r\n * Contains the registrations for the dependencies.\r\n *\r\n * {@link ServiceRegistry#create} to instantiate the register\r\n * {@link ServiceRegistry#scope} to create a {@link ServiceProvider}\r\n */\r\nexport class ServiceRegistry<T extends Record<string, any> = {}> {\r\n  private constructor(\r\n    private descriptors: Map<string, Descriptor<any, ServiceProvider>>,\r\n  ) {}\r\n\r\n  /**\r\n   * Creates a new ServiceRegistry\r\n   */\r\n  static create(): ServiceRegistry {\r\n    return new ServiceRegistry(new Map());\r\n  }\r\n\r\n  private singletons = new Map<string, any>();\r\n\r\n  /**\r\n   * Adds a dependency to the register with the chosen {@link DescriptionType}.\r\n   *\r\n   * Available dependency scopes\r\n   * - \"singleton\" Only instantiated once per {@link ServiceRegistry}\r\n   * - \"scoped\" Only instantiated once per scope see {@link ServiceRegistry#scope}\r\n   * - \"transient\" Instantiated every time it is requested\r\n   *\r\n   * @param type The dependency scope\r\n   * @param key Key that the service can be retreived with.\r\n   * @param factory Produces a new instance of the service.\r\n   */\r\n  add<TKey extends string, TOutput>(\r\n    type: DescriptorType,\r\n    key: Exclude<TKey, keyof T>,\r\n    factory: SimplifyFn<ServiceFactory<TOutput, ServiceProvider<T>>>,\r\n  ): ServiceRegistry<Simplify<T & { [key in TKey]: TOutput }>> {\r\n    const descriptors = new Map(this.descriptors);\r\n    descriptors.set(key, { type, factory: factory as ServiceFactory });\r\n    return new ServiceRegistry(descriptors);\r\n  }\r\n\r\n  /**\r\n   * Adds a singleton dependency to the register.\r\n   *\r\n   * Singletons are instantiated once per {@link ServiceRegistry}.\r\n   *\r\n   * @param key Key that the service can be retreived with.\r\n   * @param factory Produces a new instance of the service.\r\n   */\r\n  addSingleton<TKey extends string, TOutput>(\r\n    key: Exclude<TKey, keyof T>,\r\n    factory: SimplifyFn<ServiceFactory<TOutput, ServiceProvider<T>>>,\r\n  ): ServiceRegistry<Simplify<T & { [key in TKey]: TOutput }>> {\r\n    return this.add(\"singleton\", key, factory);\r\n  }\r\n\r\n  /**\r\n   * Adds a scoped dependency to the register.\r\n   *\r\n   * Scoped dependencies are instantiated once per {@link ServiceProvider}.\r\n   * See {@link ServiceRegistry#scope} for how to create a new scope and {@link ServiceProvider}.\r\n   *\r\n   * @param key Key that the service can be retreived with.\r\n   * @param factory Produces a new instance of the service.\r\n   */\r\n  addScoped<TKey extends string, TOutput>(\r\n    key: Exclude<TKey, keyof T>,\r\n    factory: SimplifyFn<ServiceFactory<TOutput, ServiceProvider<T>>>,\r\n  ): ServiceRegistry<Simplify<T & { [key in TKey]: TOutput }>> {\r\n    return this.add(\"scoped\", key, factory);\r\n  }\r\n\r\n  /**\r\n   * Adds a transient dependency to the register.\r\n   *\r\n   * Transient dependencies are instantiated every time they are requested from the {@link ServiceProvider}.\r\n   *\r\n   * @param key Key that the service can be retreived with.\r\n   * @param factory Produces a new instance of the service.\r\n   */\r\n  addTransient<TKey extends string, TOutput>(\r\n    key: Exclude<TKey, keyof T>,\r\n    factory: SimplifyFn<ServiceFactory<TOutput, ServiceProvider<T>>>,\r\n  ): ServiceRegistry<Simplify<T & { [key in TKey]: TOutput }>> {\r\n    return this.add(\"transient\", key, factory);\r\n  }\r\n\r\n  /**\r\n   * Creates a new {@link ServiceProvider}.\r\n   *\r\n   * Scoped dependencies are instantiated once per {@link ServiceProvider}.\r\n   * {@link ServiceProvider}s are effectivelty scopes.\r\n   */\r\n  scope(): Simplify<ServiceProvider<T>> {\r\n    const scoped = new Map<string, any>();\r\n\r\n    const entries = Array.from(this.descriptors).map(([key, descriptor]) => {\r\n      if (descriptor.type === \"transient\") {\r\n        return [key, () => descriptor.factory(container)] as const;\r\n      }\r\n\r\n      const storage = descriptor.type === \"scoped\" ? scoped : this.singletons;\r\n\r\n      return [\r\n        key,\r\n        () => {\r\n          if (storage.has(key)) return storage.get(key)!;\r\n          const created = descriptor.factory(container);\r\n          storage.set(key, created);\r\n          return created;\r\n        },\r\n      ] as const;\r\n    });\r\n\r\n    const container = Object.fromEntries(entries) as ServiceProvider<T>;\r\n    return container;\r\n  }\r\n}\r\n\r\n/**\r\n * Provides services by the key that it was registered with.\r\n */\r\nexport type ServiceProvider<\r\n  T extends Record<string, any> = Record<string, any>,\r\n> = {\r\n  [TKey in keyof T]: () => T[TKey];\r\n};\r\n"],"mappings":";AAuCO,IAAM,kBAAN,MAAM,iBAAoD;AAAA,EACvD,YACE,aACR;AADQ;AAUV,SAAQ,aAAa,oBAAI,IAAiB;AAAA,EATvC;AAAA;AAAA;AAAA;AAAA,EAKH,OAAO,SAA0B;AAC/B,WAAO,IAAI,iBAAgB,oBAAI,IAAI,CAAC;AAAA,EACtC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAgBA,IACE,MACA,KACA,SAC2D;AAC3D,UAAM,cAAc,IAAI,IAAI,KAAK,WAAW;AAC5C,gBAAY,IAAI,KAAK,EAAE,MAAM,QAAmC,CAAC;AACjE,WAAO,IAAI,iBAAgB,WAAW;AAAA,EACxC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,aACE,KACA,SAC2D;AAC3D,WAAO,KAAK,IAAI,aAAa,KAAK,OAAO;AAAA,EAC3C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWA,UACE,KACA,SAC2D;AAC3D,WAAO,KAAK,IAAI,UAAU,KAAK,OAAO;AAAA,EACxC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,aACE,KACA,SAC2D;AAC3D,WAAO,KAAK,IAAI,aAAa,KAAK,OAAO;AAAA,EAC3C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,QAAsC;AACpC,UAAM,SAAS,oBAAI,IAAiB;AAEpC,UAAM,UAAU,MAAM,KAAK,KAAK,WAAW,EAAE,IAAI,CAAC,CAAC,KAAK,UAAU,MAAM;AACtE,UAAI,WAAW,SAAS,aAAa;AACnC,eAAO,CAAC,KAAK,MAAM,WAAW,QAAQ,SAAS,CAAC;AAAA,MAClD;AAEA,YAAM,UAAU,WAAW,SAAS,WAAW,SAAS,KAAK;AAE7D,aAAO;AAAA,QACL;AAAA,QACA,MAAM;AACJ,cAAI,QAAQ,IAAI,GAAG,EAAG,QAAO,QAAQ,IAAI,GAAG;AAC5C,gBAAM,UAAU,WAAW,QAAQ,SAAS;AAC5C,kBAAQ,IAAI,KAAK,OAAO;AACxB,iBAAO;AAAA,QACT;AAAA,MACF;AAAA,IACF,CAAC;AAED,UAAM,YAAY,OAAO,YAAY,OAAO;AAC5C,WAAO;AAAA,EACT;AACF;","names":[]}