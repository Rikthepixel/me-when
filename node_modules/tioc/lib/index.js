"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  ServiceRegistry: () => ServiceRegistry
});
module.exports = __toCommonJS(src_exports);
var ServiceRegistry = class _ServiceRegistry {
  constructor(descriptors) {
    this.descriptors = descriptors;
    this.singletons = /* @__PURE__ */ new Map();
  }
  /**
   * Creates a new ServiceRegistry
   */
  static create() {
    return new _ServiceRegistry(/* @__PURE__ */ new Map());
  }
  /**
   * Adds a dependency to the register with the chosen {@link DescriptionType}.
   *
   * Available dependency scopes
   * - "singleton" Only instantiated once per {@link ServiceRegistry}
   * - "scoped" Only instantiated once per scope see {@link ServiceRegistry#scope}
   * - "transient" Instantiated every time it is requested
   *
   * @param type The dependency scope
   * @param key Key that the service can be retreived with.
   * @param factory Produces a new instance of the service.
   */
  add(type, key, factory) {
    const descriptors = new Map(this.descriptors);
    descriptors.set(key, { type, factory });
    return new _ServiceRegistry(descriptors);
  }
  /**
   * Adds a singleton dependency to the register.
   *
   * Singletons are instantiated once per {@link ServiceRegistry}.
   *
   * @param key Key that the service can be retreived with.
   * @param factory Produces a new instance of the service.
   */
  addSingleton(key, factory) {
    return this.add("singleton", key, factory);
  }
  /**
   * Adds a scoped dependency to the register.
   *
   * Scoped dependencies are instantiated once per {@link ServiceProvider}.
   * See {@link ServiceRegistry#scope} for how to create a new scope and {@link ServiceProvider}.
   *
   * @param key Key that the service can be retreived with.
   * @param factory Produces a new instance of the service.
   */
  addScoped(key, factory) {
    return this.add("scoped", key, factory);
  }
  /**
   * Adds a transient dependency to the register.
   *
   * Transient dependencies are instantiated every time they are requested from the {@link ServiceProvider}.
   *
   * @param key Key that the service can be retreived with.
   * @param factory Produces a new instance of the service.
   */
  addTransient(key, factory) {
    return this.add("transient", key, factory);
  }
  /**
   * Creates a new {@link ServiceProvider}.
   *
   * Scoped dependencies are instantiated once per {@link ServiceProvider}.
   * {@link ServiceProvider}s are effectivelty scopes.
   */
  scope() {
    const scoped = /* @__PURE__ */ new Map();
    const entries = Array.from(this.descriptors).map(([key, descriptor]) => {
      if (descriptor.type === "transient") {
        return [key, () => descriptor.factory(container)];
      }
      const storage = descriptor.type === "scoped" ? scoped : this.singletons;
      return [
        key,
        () => {
          if (storage.has(key)) return storage.get(key);
          const created = descriptor.factory(container);
          storage.set(key, created);
          return created;
        }
      ];
    });
    const container = Object.fromEntries(entries);
    return container;
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ServiceRegistry
});
//# sourceMappingURL=index.js.map